<!DOCTYPE html>
<html>
<head>
	<title>The Story of a Japanese High School</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Added for mobile friendliness -->

	<!-- MapLibre GL JS -->
	<script src='https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js'></script>
	<link href='https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css' rel='stylesheet' />

	<!-- jquery -->
	<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

	<!-- stylesheets -->
	<link rel="stylesheet" href="style.css">

</head>
<body>

	<div id="welcome-modal-overlay">
		<div id="welcome-modal-content">
			<h1>Mapろう！</h1>
			<img src="images/qrcode.png" alt="QR Code" id="modal-qrcode">
			<a href="https://docs.google.com/forms/d/e/1FAIpQLSfXPt1yca5nZY26U4hsEinVi0WsFPqheEV-ed_TiX7KtzGp-g/viewform?usp=header" target="_blank" id="form-link">あなたも地図に載ろう！➡︎</a>
			<p class="slogan">地図と物語で、未知の世界へ飛び込もう！</p>
			<button id="modal-close-button">冒険を始める！ <br>Begin your journey &rarr;</button>
		</div>
	</div>

	<div class="header">
		<!-- <img src="http://www.shutoku.ac.jp/img/common/header__logo@2x.png" width=> -->
		<!-- <img src="images/sakura.png" width=> -->
		<!-- <a href="#" id="logo-link"><img src="images/matsudo-minami.png" width=></a> -->
		<a href="#" id="logo-link"><img src="images/kiseki.png" width=></a>
		<img src="images/me.png" width=60> 
	</div>
	<div class="main-area"> <!-- NEW WRAPPER for sidebar and content -->
		<div class="sidebar sidebar-closed"></div> <!-- Added sidebar-closed class -->
		<div class="content">
			<div id="hamburger-menu">
				<span></span>
				<span></span>
				<span></span>
			</div>
			<div id="horizontal-card-scroller"></div> <!-- New horizontal scroller div -->
			<!-- Search Feature HTML -->
			<div id="search-container">
				<input type="text" id="search-input" placeholder="Search...">
				<div id="search-icon">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg>
				</div>
			</div>
			<div id="map"></div>
			<div class="timeline-controls"></div> <!-- Added for timeline controls -->

			<script>

				// Define the URL of the REST API endpoint
				// const sheetId = '1t44Ph4w29o4N59AXAv672uTDtKpa1wxdLQAIRjveMi0';
				const sheetId = '1SkLkL2Hfw5wD3-ZfASaT5H4lCwMKRvkSGL1HZpVWMGs';

				// const apiUrl = 'https://sheets.googleapis.com/v4/spreadsheets/'+sheetId+'/values/Form Responses 1?key=AIzaSyAUi4KazffmDZV_dQUnMUKA1jJt4i0mqlU';

				const apiUrl = 'https://sheets.googleapis.com/v4/spreadsheets/'+sheetId+'/values/map?key=AIzaSyAUi4KazffmDZV_dQUnMUKA1jJt4i0mqlU';

				let sheet = null;
				let sheet2 = []; // Initialize sheet2
				// const avatarImageFiles = ['boy.png', 'girl.png', 'man.png', 'woman.png', 'old-man.png', 'old-woman.png', 'young-man.png', 'young-woman.png', 'senior-man.png', 'senior-woman.png', 'sporty-boy.png', 'sporty-girl.png', 'otaku-boy.png', 'otaku-girl.png', 'nerdy-boy.png', 'nerdy-girl.png', 'rock-boy.png', 'rock-girl.png', 'computer-boy.png', 'computer-girl.png', 'anime-boy.png', 'anime-girl.png', 'basketball-boy.png', 'basketball-girl.png', 'soccer-boy.png', 'soccer-girl.png', 'artist-boy.png', 'artist-girl.png'];
				// AvatarImageFiles is no longer needed as avatar name comes from sheet

				let map; // Declare map globally
				let markers = []; // To keep track of marker instances
				let basemapLayers = [];
				let currentFilteredData = []; // For search results

				let currentBasemapId = 'google-satellite'; // Default active basemap changed to Google Satellite ("Today")
				// Global state for initial map view, potentially from URL
				let mapInitState = { lat: null, lon: null, zoom: null, basemapIdFromUrl: null, urlStateApplied: false };

				function initializeBasemapData() {
					basemapLayers = [

						{
							id: 'gsi-ort-old10',
							name: '1961',
							group: 'GSI',
							note: 'Coverage may be limited.',
							style: {
								version: 8,
								sources: { 'gsi-ort-old10': { type: 'raster', tiles: ['https://cyberjapandata.gsi.go.jp/xyz/ort_old10/{z}/{x}/{y}.png'], tileSize: 256, attribution: '地理院タイル &copy; <a href="https://www.gsi.go.jp/" target="_blank">国土地理院</a>' }},
								layers: [{ id: 'gsi-ort-old10-layer', type: 'raster', source: 'gsi-ort-old10', minzoom: 0, maxzoom: 17 }]
							}
						},
						{
							id: 'gsi-gazo1',
							name: '1974',
							group: 'GSI',
							note: 'Coverage may be limited. JPG format.',
							style: {
								version: 8,
								sources: { 'gsi-gazo1': { type: 'raster', tiles: ['https://cyberjapandata.gsi.go.jp/xyz/gazo1/{z}/{x}/{y}.jpg'], tileSize: 256, attribution: '地理院タイル &copy; <a href="https://www.gsi.go.jp/" target="_blank">国土地理院</a>' }},
								layers: [{ id: 'gsi-gazo1-layer', type: 'raster', source: 'gsi-gazo1', minzoom: 0, maxzoom: 17 }]
							}
						},
						{
							id: 'gsi-gazo2',
							name: '1979',
							group: 'GSI',
							note: 'Coverage may be limited. JPG format.',
							style: {
								version: 8,
								sources: { 'gsi-gazo2': { type: 'raster', tiles: ['https://cyberjapandata.gsi.go.jp/xyz/gazo2/{z}/{x}/{y}.jpg'], tileSize: 256, attribution: '地理院タイル &copy; <a href="https://www.gsi.go.jp/" target="_blank">国土地理院</a>' }},
								layers: [{ id: 'gsi-gazo2-layer', type: 'raster', source: 'gsi-gazo2', minzoom: 0, maxzoom: 17 }]
							}
						},
						{
							id: 'gsi-gazo3',
							name: '1984',
							group: 'GSI',
							note: 'Coverage may be limited. JPG format.',
							style: {
								version: 8,
								sources: { 'gsi-gazo3': { type: 'raster', tiles: ['https://cyberjapandata.gsi.go.jp/xyz/gazo3/{z}/{x}/{y}.jpg'], tileSize: 256, attribution: '地理院タイル &copy; <a href="https://www.gsi.go.jp/" target="_blank">国土地理院</a>' }},
								layers: [{ id: 'gsi-gazo3-layer', type: 'raster', source: 'gsi-gazo3', minzoom: 0, maxzoom: 17 }]
							}
						},
						{
							id: 'gsi-gazo4',
							name: '1987',
							group: 'GSI',
							note: 'Coverage may be limited. JPG format.',
							style: {
								version: 8,
								sources: { 'gsi-gazo4': { type: 'raster', tiles: ['https://cyberjapandata.gsi.go.jp/xyz/gazo4/{z}/{x}/{y}.jpg'], tileSize: 256, attribution: '地理院タイル &copy; <a href="https://www.gsi.go.jp/" target="_blank">国土地理院</a>' }},
								layers: [{ id: 'gsi-gazo4-layer', type: 'raster', source: 'gsi-gazo4', minzoom: 0, maxzoom: 17 }]
							}
						},
						{
							id: 'google-satellite',
							name: 'Today',
							group: 'Google',
							note: 'Usage may be subject to Google Maps Platform Terms of Service.',
							style: {
								version: 8,
								sources: { 'google-satellite': { type: 'raster', tiles: ['https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'], tileSize: 256, attribution: 'Map data &copy; <a href="https://www.google.com/intl/en_us/help/terms_maps/" target="_blank">Google</a>', maxzoom: 21 }},
								layers: [{ id: 'google-satellite-layer', type: 'raster', source: 'google-satellite' }]
							}
						}
					];
				}

				// Use the fetch function to make a GET request
				fetch(apiUrl)
				.then(response => {
					// Check if the response status is OK (200)
					if (!response.ok) {
					throw new Error('Network response was not ok');
					}
					// Parse the response as JSON
					return response.json();
				})
				.then(data => {
					// Handle the JSON data here
					sheet = data.values
					console.log(sheet)
					let id = 0
					sheet.forEach(function(element){
						// Original sheet structure:
						// Col 0: Timestamp, Col 1: Author, Col 2: Title, Col 3: Description, Col 4: Coords
						// Col 5: Age, Col 6: Avatar Name (e.g., "sport-boy"), Col 7: Hashtag, Col 8: Genre
						// We need at least up to Avatar Name (index 6) and Coords (index 4) to be present.
						if(id > 0 && element && element.length > 6 && element[4] !== undefined && element[6] !== undefined)
						{
							let coordSource = element[4];
							let processedCoordString = null;

							if (typeof coordSource === 'string') {
								processedCoordString = coordSource.trim(); 
								if (processedCoordString.startsWith('[') && processedCoordString.endsWith(']')) {
									processedCoordString = processedCoordString.slice(1, -1).trim(); 
								} else if (processedCoordString.startsWith('(') && processedCoordString.endsWith(')')) {
									processedCoordString = processedCoordString.slice(1, -1).trim(); 
								}
							}

							if (processedCoordString && processedCoordString.includes(',')) {
								element[4] = processedCoordString; // Update element with cleaned string
								
								// Construct avatar URL from Avatar Name (element[6])
								const avatarName = element[6];
								const avatarUrl = `images/avatars/${avatarName}.png`;
								element.push(avatarUrl); // Add constructed avatarUrl to the end of the element array

								element.unshift(id); // Add a unique ID to the beginning of each row
								sheet2.push(element);
							} else {
								console.warn("Skipping row due to invalid coordinates (no comma after processing):", element, "Raw coord data:", coordSource);
							}
						} else if (id > 0) { 
							console.warn("Skipping row due to incomplete data structure (expected at least 7 columns for essential data, up to Avatar Name) or missing coordinates/avatar name:", element);
						}
						id++
					})
					console.log(sheet2)
					currentFilteredData = [...sheet2]; // Initialize with all data
					setupMapAndUI(); // New main setup function
				})
				.catch(error => {
					// Handle errors
					console.error('Fetch error:', error);
				});

				function setupMapAndUI() {
					console.log("Setting up map and UI...");
					parseUrlHash(); 
					initializeBasemapData(); 
					if (mapInitState.basemapIdFromUrl && basemapLayers.find(b => b.id === mapInitState.basemapIdFromUrl)) {
						currentBasemapId = mapInitState.basemapIdFromUrl;
					}
					initMapInstance(); // This will call refreshMapContent internally on style.load
					populateSidebar(currentFilteredData); 
					populateHorizontalScroller(currentFilteredData); 
					createTimelineControls(); 
					setupHamburgerMenu();
					setupHeaderLogoLink();
					setupModal();
					setupSearchFeature(); // Add this call
				}

				function setupModal() {
					const modalOverlay = document.getElementById('welcome-modal-overlay');
					const modalCloseButton = document.getElementById('modal-close-button');

					if (modalOverlay && modalCloseButton) {
						modalCloseButton.addEventListener('click', () => {
							modalOverlay.classList.add('modal-hidden');
						});
					}
				}

				function setupHeaderLogoLink() {
					const logoLink = document.getElementById('logo-link');
					if (logoLink) {
						logoLink.addEventListener('click', (event) => {
							event.preventDefault(); // Prevent default anchor behavior
							window.location.hash = ''; // Clear the hash
							window.location.reload(); // Reload the page to reset to defaults
						});
					}
				}

				function setupHamburgerMenu() {
					const hamburger = document.getElementById('hamburger-menu');
					const sidebar = document.querySelector('.sidebar');
					// const mainArea = document.querySelector('.main-area'); // No longer toggling class on main-area

					if (hamburger && sidebar) {
						hamburger.addEventListener('click', () => {
							sidebar.classList.toggle('sidebar-closed');
							// mainArea.classList.toggle('sidebar-closed'); // Removed
							// It's important to resize the map after the transition/animation of sidebar is complete
							// or at least after the class change has taken effect.
							// A small timeout can help if there are CSS transitions.
							setTimeout(() => {
								if (map) {
									map.resize();
								}
							}, 250); // Adjust timeout based on CSS transition duration
						});
					}
				}

				function parseUrlHash() {
					if (window.location.hash) {
						const hash = window.location.hash.substring(1); // Remove #
						// Expected format: !map=zoom/lat/lon/basemapId
						if (hash.startsWith('!map=')) {
							const parts = hash.substring(5).split('/');
							if (parts.length >= 3) { // zoom, lat, lon are minimum
								const zoom = parseFloat(parts[0]);
								const lat = parseFloat(parts[1]);
								const lon = parseFloat(parts[2]);

								if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lon)) {
									mapInitState.zoom = zoom;
									mapInitState.lat = lat;
									mapInitState.lon = lon;
									mapInitState.urlStateApplied = true;
									console.log("Map state from URL:", mapInitState);
								}
								if (parts.length >= 4 && parts[3]) {
									mapInitState.basemapIdFromUrl = parts[3];
									// currentBasemapId will be updated in setupMapAndUI if valid
								}
							}
						}
					}
				}

				function updateUrlHash() {
					if (!map) return;
					const center = map.getCenter();
					const zoom = map.getZoom();
					const lat = parseFloat(center.lat.toFixed(6)); // Limit precision
					const lon = parseFloat(center.lng.toFixed(6)); // Limit precision
					
					// Update global state for consistency if needed, though map is source of truth here
					// mapInitState.lat = lat; 
					// mapInitState.lon = lon;
					// mapInitState.zoom = zoom;

					const newHash = `!map=${zoom}/${lat}/${lon}/${currentBasemapId}`;
					// Use replaceState to avoid flooding browser history for every map move
					if (history.replaceState) {
						history.replaceState(null, null, '#' + newHash);
					} else {
						window.location.hash = newHash;
					}
				}


				function initMapInstance() {
					console.log("Initializing MapLibre map instance...");
					const initialBasemap = basemapLayers.find(b => b.id === currentBasemapId);
					if (!initialBasemap) {
						console.error("Initial basemap style not found:", currentBasemapId);
						// Fallback to a very basic style if default is missing, or handle error appropriately
						// Attempt to use the first defined basemap as a fallback if currentBasemapId is somehow invalid
						const fallbackBasemap = basemapLayers.length > 0 ? basemapLayers[0] : null;
						if (fallbackBasemap) {
							console.warn("Falling back to first defined basemap:", fallbackBasemap.id);
							currentBasemapId = fallbackBasemap.id;
							map = new maplibregl.Map({ container: 'map', style: fallbackBasemap.style, center: [140.123, 35.605], 
							zoom: 10,
							pitch: 60, // Tilt the map
							bearing: -17.6 // Optional: slight bearing for better 3D view

						 });
						} else {
							// Absolute fallback if no basemaps are defined
							 map = new maplibregl.Map({ container: 'map', center: [140.123, 35.605], zoom: 10,
							pitch: 60, // Tilt the map
							bearing: -17.6 // Optional: slight bearing for better 3D view
});
						}
						map.on('style.load', refreshMapContent);
						return;
					}

					let initialCenter = [140.123, 35.605]; // New default center
					let initialZoom = 10;       // New default zoom

					if (mapInitState.urlStateApplied && mapInitState.lon !== null && mapInitState.lat !== null) {
						initialCenter = [mapInitState.lon, mapInitState.lat];
					}
					if (mapInitState.urlStateApplied && mapInitState.zoom !== null) {
						initialZoom = mapInitState.zoom;
					}

					map = new maplibregl.Map({
						container: 'map',
						style: initialBasemap.style,
						center: initialCenter,
						zoom: initialZoom,
							pitch: 60, // Tilt the map
							bearing: -17.6 // Optional: slight bearing for better 3D view

					});

					// map.addControl(new maplibregl.NavigationControl());

					map.on('style.load', () => {
						console.log("Map style loaded.");
						refreshMapContent(currentFilteredData); // Pass current (possibly filtered) data

					});

					map.on('moveend', updateUrlHash);
					map.on('zoomend', updateUrlHash);
				}
				
				function refreshMapContent(dataToDisplay) { // Modified to accept data
					if (!map || !dataToDisplay) { // Check dataToDisplay
						console.log("Map not ready or no data for markers.");
						return;
					}

					// Clear existing markers
					markers.forEach(marker => marker.remove());
					markers = []; // Reset markers array

					const bounds = new maplibregl.LngLatBounds();
					let validMarkersExist = false;
					
					dataToDisplay.forEach(function(item, index){ // Use dataToDisplay
						// New sheet2 item structure after processing:
						// item[0]=id (generated)
						// item[1]=Timestamp (original col 0)
						// item[2]=Author (original col 1)
						// item[3]=Title (original col 2)
						// item[4]=Description (original col 3)
						// item[5]=Coordinates (original col 4, "lat,lon" string)
						// item[6]=Age (original col 5)
						// item[7]=Avatar Name (raw, original col 6, e.g., "sport-boy")
						// item[8]=Hashtag (original col 7, might be undefined if not present in sheet)
						// item[9]=Genre (original col 8, might be undefined if not present in sheet)
						// item[10]=avatarUrl (constructed: images/avatars/${original_col_6}.png)

						if (!item[5] || typeof item[5] !== 'string' || !item[5].includes(',')) {
							console.warn("Skipping item in refreshMapContent due to missing or invalid coordinates string at item[5]:", item[3] || `Item ID ${item[0]}`, "Coords string:", item[5]);
							return;
						}
						if (!item[10]) { // Check for avatarUrl (now at index 10)
							console.warn("Skipping item in refreshMapContent due to missing avatarUrl at item[10]:", item[3] || `Item ID ${item[0]}`);
							return;
						}

						const itemId = item[0]; 

						let latlonArray; 
						try {
							latlonArray = item[5].split(',').map(Number); 
							if (latlonArray.length !== 2 || isNaN(latlonArray[0]) || isNaN(latlonArray[1])) {
								throw new Error("Invalid coordinate format");
							}
						} catch (e) {
							console.warn("Error parsing coordinates for item:", item[3] || `Item ID ${item[0]}`, item[5], e);
							return;
						}
						
						let lngLat = [latlonArray[1], latlonArray[0]]; 
						const author = item[2] || 'N/A';
						const title = item[3] || 'N/A';
						const description = item[4] || 'No description.';
						const imageUrl = item[10]; // Use constructed avatarUrl from item[10]
						const genre = item[9] || ''; // Genre from item[9]
						const hashtag = item[8] || ''; // Hashtag from item[8]
						
						 const markerContainer = document.createElement('div');
						 markerContainer.style.display = 'flex';
						 markerContainer.style.flexDirection = 'column';
						 markerContainer.style.alignItems = 'center';
						 markerContainer.style.cursor = 'pointer'; // Add pointer cursor to indicate clickable
						 
						const iconEl = document.createElement('div');
						iconEl.style.backgroundImage = `url(${imageUrl})`;
						iconEl.style.width = '48px';
						iconEl.style.height = '48px';
						iconEl.style.borderRadius = '50%'; 
						iconEl.style.backgroundSize = 'cover'; 
						iconEl.style.backgroundRepeat = 'no-repeat'; 
						iconEl.style.backgroundPosition = 'center'; 

						 const lineEl = document.createElement('div');
						 lineEl.style.width = '2px';
						 lineEl.style.height = '30px'; 
						 lineEl.style.backgroundColor = 'white';

						 markerContainer.appendChild(iconEl); 
						 markerContainer.appendChild(lineEl); 

						markerContainer.addEventListener('click', (event) => {
							event.stopPropagation(); 
							goto(itemId);
						});

						// Updated Popup HTML with Genre and Hashtag
						let genrePillHTML = '';
						if (genre) {
							const genreParts = genre.split(' ');
							const firstWordOfGenre = genreParts[0];
							// Add onclick to trigger search with the first word of the genre
							genrePillHTML = `<span class="popup-genre-pill" title="${genre}" onclick="triggerSearchFromElement(this, '${firstWordOfGenre.replace(/'/g, "\\'")}')">${firstWordOfGenre}</span>`;
						}
						
						let hashtagHTML = '';
						if (hashtag) {
							// Add onclick to trigger search with the hashtag text
							hashtagHTML = `<p class="popup-hashtag" onclick="triggerSearchFromElement(this, '${hashtag.replace(/'/g, "\\'")}')">${hashtag}</p>`;
						}


						const popupHTML = `
							<img src="${imageUrl}" class="popup-protruding-icon">
							<div class="popup-text-content">
								<h3>${title}</h3>
								${genrePillHTML}
								<p class="popup-author-detail">${author}</p>
								<p>${description}</p>
								${hashtagHTML}
							</div>`;
						
						const popup = new maplibregl.Popup({ offset: 25 }) 
							.setHTML(popupHTML);

						const marker = new maplibregl.Marker({ 
							element: markerContainer,
							anchor: 'bottom', 
						}) 
							.setLngLat(lngLat)
							.setPopup(popup) // MapLibre will still handle its default popup toggle
							.addTo(map);
						
						markers.push(marker);
						
						bounds.extend(lngLat);
						validMarkersExist = true;
					});
					
					// Only fitBounds if the view wasn't set by URL parameters AND it's the initial load (no search term)
					if (!mapInitState.urlStateApplied && validMarkersExist && !bounds.isEmpty() && document.getElementById('search-input').value === '') {
						map.fitBounds(bounds, {
							padding: {top: 100, bottom:100, left: 100, right: 100}, 
							maxZoom: 17 
						});
					} else if (!mapInitState.urlStateApplied && dataToDisplay.length > 0 && (!validMarkersExist || bounds.isEmpty())) {
						console.warn("No valid markers to bound for current filter, map initialized with default/current center/zoom.");
					} else if (!mapInitState.urlStateApplied && dataToDisplay.length === 0) {
						 console.log("No data for current filter, map initialized with default/current center/zoom.");
					}
				}
				
				function populateSidebar(dataToDisplay) { // Modified to accept data
					const sidebar = $('.sidebar');
					sidebar.empty(); 
					if (!dataToDisplay || dataToDisplay.length === 0) return; // Check dataToDisplay

					dataToDisplay.forEach(function(item){ // Use dataToDisplay
						 // item[0]=id, item[2]=Author, item[10]=avatarUrl
						 if (item[0] === undefined || item[2] === undefined || item[10] === undefined) { 
							return;
						}
						const itemId = item[0];
						const author = item[2];
						const avatarUrl = item[10]; // Avatar URL is at index 10

						const sidebarItemHTML = `
							<div class="sidebar-item" onclick="goto(${itemId})">
								<img src="${avatarUrl}" class="sidebar-item-icon-img">
								<p class="sidebar-item-author-name">${author}</p>
							</div>`;
						sidebar.append(sidebarItemHTML);
					});
				}

				function populateHorizontalScroller(dataToDisplay) { // Modified to accept data
					const scroller = $('#horizontal-card-scroller');
					scroller.empty();
					if (!dataToDisplay || dataToDisplay.length === 0) return; // Check dataToDisplay

					dataToDisplay.forEach(function(item) { // Use dataToDisplay
						// item[0]=id, item[2]=Author, item[10]=avatarUrl
						if (item[0] === undefined || item[2] === undefined || item[10] === undefined) {
							return;
						}
						const itemId = item[0];
						const author = item[2];
						const avatarUrl = item[10]; // Avatar URL is at index 10

						const cardHTML = `
							<div class="horizontal-card" data-id="${itemId}" onclick="goto(${itemId})">
								<img src="${avatarUrl}" class="horizontal-card-icon-img">
								<p class="horizontal-card-author-name">${author}</p>
							</div>`;
						scroller.append(cardHTML);
					});
				}

				function createTimelineControls() {
					const controlsContainer = document.querySelector('.timeline-controls');
					if (!controlsContainer) {
						console.error("Timeline controls container not found.");
						return;
					}
					controlsContainer.innerHTML = ''; // Clear existing controls

					basemapLayers.forEach(layer => {
						const itemContainer = document.createElement('div');
						itemContainer.className = 'timeline-item';
						itemContainer.title = layer.note || layer.name; 
						itemContainer.dataset.basemapId = layer.id;

						const circle = document.createElement('div');
						circle.className = 'timeline-circle';
						if (layer.id === currentBasemapId) {
							circle.classList.add('active');
						}
						
						const label = document.createElement('span');
						label.className = 'timeline-label';
						label.textContent = layer.name; 

						itemContainer.appendChild(circle);
						itemContainer.appendChild(label);

						itemContainer.addEventListener('click', () => {
							switchBasemap(layer.id);
						});
						controlsContainer.appendChild(itemContainer);
					});
				}

				function triggerSearchFromElement(element, searchTerm) {
					const searchContainer = document.getElementById('search-container');
					const searchInput = document.getElementById('search-input');

					if (!searchContainer.classList.contains('search-active')) {
						searchContainer.classList.add('search-active');
					}
					searchInput.value = searchTerm;
					searchInput.focus();
					filterAndRefreshUI(searchTerm.toLowerCase());
				}

				function setupSearchFeature() {
					const searchContainer = document.getElementById('search-container');
					const searchIcon = document.getElementById('search-icon');
					const searchInput = document.getElementById('search-input');

					searchIcon.addEventListener('click', () => {
						searchContainer.classList.toggle('search-active');
						if (searchContainer.classList.contains('search-active')) {
							searchInput.focus();
						} else {
							searchInput.value = ''; // Clear search on close
							filterAndRefreshUI(''); // Reset filter
						}
					});

					searchInput.addEventListener('input', (event) => {
						const searchTerm = event.target.value.toLowerCase();
						filterAndRefreshUI(searchTerm);
					});
				}

				function filterAndRefreshUI(searchTerm) {
					if (!searchTerm || searchTerm.trim() === '') {
						currentFilteredData = [...sheet2];
					} else {
						currentFilteredData = sheet2.filter(item => {
							const author = (item[2] || '').toLowerCase();
							const title = (item[3] || '').toLowerCase();
							const description = (item[4] || '').toLowerCase();
							const hashtag = (item[8] || '').toLowerCase();
							const genre = (item[9] || '').toLowerCase(); // Full genre string for searching

							return author.includes(searchTerm) ||
								   title.includes(searchTerm) ||
								   description.includes(searchTerm) ||
								   hashtag.includes(searchTerm) ||
								   genre.includes(searchTerm);
						});
					}
					// When map style reloads (e.g. basemap change), it calls refreshMapContent.
					// We need to ensure it uses the latest filtered data.
					// So, directly call refreshMapContent here.
					refreshMapContent(currentFilteredData);
					populateSidebar(currentFilteredData);
					populateHorizontalScroller(currentFilteredData);
					// Active card highlighting in goto() will still work based on IDs.
				}

				function switchBasemap(basemapId) {
					const newBasemap = basemapLayers.find(b => b.id === basemapId);
					
					if (newBasemap && newBasemap.id !== currentBasemapId) {
						currentBasemapId = newBasemap.id;
						map.setStyle(newBasemap.style); // This will trigger 'style.load' which calls refreshMapContent
						// Update URL hash after basemap change
						updateUrlHash();

						document.querySelectorAll('.timeline-controls .timeline-item').forEach(itemEl => {
							const circleEl = itemEl.querySelector('.timeline-circle');
							if (circleEl) {
								if (itemEl.dataset.basemapId === currentBasemapId) {
									circleEl.classList.add('active');
								} else {
									circleEl.classList.remove('active');
								}
							}
						});
					} else if (newBasemap && newBasemap.id === currentBasemapId) {
						console.log("Basemap already active:", basemapId);
					}
				}

				function goto(id){
						console.log("Going to ID:", id);

						// Highlight the card in the horizontal scroller
						const scroller = document.getElementById('horizontal-card-scroller');
						if (scroller) {
							// Remove highlight from all cards
							const allCards = scroller.querySelectorAll('.horizontal-card');
							allCards.forEach(card => card.classList.remove('horizontal-card-selected'));

							// Add highlight to the selected card
							const selectedCard = scroller.querySelector(`.horizontal-card[data-id="${id}"]`);
							if (selectedCard) {
								selectedCard.classList.add('horizontal-card-selected');
								// Scroll the selected card into view
								selectedCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
							}
						}

						const item = sheet2.find(sublist => sublist[0] === id);
						// Coordinates are now at item[5]
						if (item && item[5]) {
							// Assuming item[5] is "latitude,longitude"
							let latlonArray = item[5].split(',').map(Number); // Parses "lat,lon" string into [lat, lon]
							// MapLibre needs [longitude, latitude]
							let lngLat = [latlonArray[1], latlonArray[0]]; // Swap to [lon, lat]
							console.log("Flying to:", lngLat);
							map.flyTo({
								center: lngLat,
								// adjust speed
								speed: 0.5, // Slower flyTo speed
								zoom: 16 // Consider making this zoom level also part of URL or a setting
							});
							// updateUrlHash will be called by 'moveend' event
							// Optionally, open the popup for the marker
							const targetMarker = markers.find(m => {
								const markerLngLat = m.getLngLat();
								return markerLngLat.lng === lngLat[0] && markerLngLat.lat === lngLat[1];
							});
							if (targetMarker && !targetMarker.getPopup().isOpen()) {
								targetMarker.togglePopup();
							}

						} else {
							console.error("Could not find item or coordinates for id:", id);
						}
					}

			</script>	

		</div> <!-- Closing content div -->
	</div> <!-- Closing main-area div -->

</body>
</html>
